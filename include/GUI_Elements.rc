#ifndef __GIU_ELEMENTS__
#define __GIU_ELEMENTS__

#include <SDL2/SDL_render.h>
#include <SDL2/SDL_ttf.h>

#include <string>

SDL_Renderer* main_ren = nullptr;

class Font {
   private:
    SDL_Texture* letters[96] = {nullptr};
    int letter_width[96];
    int letter_height = 0;

   public:
    int LetterHeight() { return this->letter_height; }

    Font(const char* font_path, size_t font_size, const SDL_Color& font_color) {
        static bool ttf_init = false;
        if (!ttf_init) {
            TTF_Init();
            ttf_init = true;
        }

        TTF_Font* font = TTF_OpenFont(font_path, font_size);
        SDL_Color color = {0, 0, 0, 255};
        for (int i = 32; i < 127; i++) {
            char l[] = {char(i), '\0'};

            SDL_Surface* surf = TTF_RenderText_Blended(font, l, color);

            if (l[0] == 'A') letter_height = surf->h;

            SDL_SetColorKey(surf, SDL_TRUE,
                            SDL_MapRGB(surf->format, 255, 255, 255));
            letters[i - 32] = SDL_CreateTextureFromSurface(main_ren, surf);

            letter_width[i - 32] = surf->w;
            SDL_FreeSurface(surf);
        }

        // SDL_QueryTexture(letters['A'], NULL,NULL, &letter_width['A'],
        // &letter_height);
    }

    size_t RenderText(int x, int y, const char* text, size_t length) {
        SDL_Rect rect = {x, y, 0, letter_height};
        for (size_t i = 0; i < length; i++) {
            rect.x += rect.w;
            short index = text[i] - 32;
            if (index == -1) continue;
            if (index < 0 || index > 96) index = '*' - 32;

            rect.w = letter_width[index];
            SDL_RenderCopy(main_ren, letters[index], NULL, &rect);
        }

        return rect.x - x + rect.w;
    }

    size_t RenderTextUntil(int x, int y, const char* text, char delim,
                           size_t max_length) {
        SDL_Rect rect = {x, y, 0, letter_height};
        for (size_t i = 0; i < max_length && text[i] != delim; i++) {
            rect.w = letter_width[text[i]];
            SDL_RenderCopy(main_ren, letters[text[i]], NULL, &rect);
            rect.x += rect.w;
        }
        return rect.x - x;
    }

    SDL_Texture* ConvertToPicture(const char* text, size_t length) {
        SDL_Texture* texture = nullptr;
        SDL_SetRenderTarget(main_ren, texture);
        SDL_SetRenderDrawColor(main_ren, 0, 0, 0, 0);
        SDL_RenderClear(main_ren);

        this->RenderText(0, 0, text, length);

        SDL_SetRenderTarget(main_ren, NULL);

        return texture;
    }

    ~Font() {
        for (size_t i = 0; i < 94; i++) SDL_DestroyTexture(letters[i]);
    }

    friend class TextField;
    friend class LabelBox;
};

class TextField {
   private:
    std::string text;
    SDL_Rect rect;
    Font* font = nullptr;
    size_t length;
    static char t;

   public:
    TextField(const int& x, const int& y, int length, Font* font)
        : font(font),
          length(length),
          rect{x, y, length * font->letter_width[int('A') - 33] + 10,
               font->letter_height + 10} {}

    std::string& GetText() { return text; }

    void AddLast(const char letter) {
        this->t = 1;
        text.push_back(letter);
    }

    void RemoveLast() {
        this->t = 1;
        if (text.size() > 0) text.resize(text.size() - 1);
    }

    void Render() {
        SDL_SetRenderDrawColor(main_ren, 0, 255, 255, 255);
        SDL_RenderFillRect(main_ren, &rect);

        const char* data =
            text.data() + (text.size() < length ? 0 : text.size() - length);

        int x = font->RenderText(rect.x + 5, rect.y + 5, data,
                                 (text.size() < length ? text.size() : length));
        SDL_SetRenderDrawColor(main_ren, 0, 0, 0, 255);

        if (t > 0)
            SDL_RenderDrawLine(main_ren, x + rect.x + 5, rect.y + 3,
                               x + rect.x + 5, rect.y + rect.h - 3);
        t += 5;
    }
};
char TextField::t = 0;
// class LabelBox
//{
// private:
//	SDL_Rect word_rect;
//	Font* font;
//	SDL_Rect rect;
//	SDL_Color color;
//	struct word
//	{
//		SDL_Texture* texture;
//		int width=0;
//		word(Font* font, const char* text, int width, int length)
//		{
//			texture = SDL_CreateTexture(main_ren,
// SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_TARGET, width,
// LabelBox::font->letter_height); 			this->width = width;
// font->RenderText(0, 0, text, length);
//		};
//		int width=0;
//		SDL_Texture* texture=nullptr;
//		word* next=nullptr;
//	};
//	word* head;
// public:
//	LabelBox(int x, int y, Font* font,size_t max_length, const char*
// text,SDL_Color color) 		:font(font), rect{ x,y,int(max_length) *
// font->letter_width['A' - 33],font->letter_height + 10 },
// color(color)
//	{
//		for (int w=0, i = 0; text[i] != '\0'; i++)
//		{
//			w += font->letter_width[text[i] - 33];
//
//		}
//	}
//
//	void Render()
//	{
//		SDL_SetRenderDrawColor(main_ren, color.r, color.g, color.b,
// color.a); 		SDL_RenderFillRect(main_ren, &rect);
// SDL_RenderCopy(main_ren, word, NULL, &word_rect);
//	}
//
//	~LabelBox()
//	{
//		SDL_DestroyTexture(this->word);
//	}
// };
// #endif // !__GIU_ELEMENTS__

class LabelBox {
   private:
    std::string text;
    SDL_Rect rect;
    Font* font;
    SDL_Color color;

   public:
    LabelBox(int x, int y, int max_width, Font* font, std::string& text,
             SDL_Color& color)
        : rect{x, y, max_width, 0}, font(font), color(color) {
        this->text.assign(text);
        rect.h = text.size() * font->letter_width['A' - 33] / max_width *
                 (font->letter_height + 10);
    }

    void Render() {
        SDL_SetRenderDrawColor(main_ren, color.r, color.g, color.b, color.a);
        SDL_RenderFillRect(main_ren, &rect);
        int h = rect.h + 5;
        size_t index = 20;
        int space = 0;
        const char* begin = text.data();
        while (index < text.size()) {
            int length = 20;
            space += font->RenderTextUntil(rect.x + 5, h, begin, ' ', length);
            index += length;
            if (space > rect.w - 20) {
                space = 0;
                h += font->letter_height + 3;
            }
        };
    }
};
#endif
